#include <stdio.h>
#include "miracl.h"
#include <time.h>
#include <string.h>
#include <stdlib.h>

int shine(big pk);
static char *rand_string(char *str, size_t size);
char* rand_string_alloc(size_t size);

/* Use secp256k1 elliptic curve: y^2=x^3 + 7 */

/* Prime of the finite field */

char *ecp="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F";

/* elliptic curve parameter B */

char *ecb="7";

/* Generator point of secp256k1 */

char *ecx="79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798";
char *ecy="483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8";

/* Order of the group generated by G, such that nG = Infinity */

char *ecn="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141";

/* Data to be encrypted */
char dest[32] = "SHINE!"; 

int main()
{
    big pk;
    miracl *mip;

    /* Repeat until a valid ciphertext is generated */ 
    do {} while (shine(pk)==0);    

    return 0;
}


int shine(big pk)
{
    int ik,n;
    int rand_len = 16;
    int ptx_len = 32;
    time_t seed;
    epoint *g,*ek,*ea,*eb;
    big nn,yd,z,a,b,m,p,q,x,y,k,k2,inv,inv2,t,r;
    miracl *mip;
    char *ptr;
    char c[100];
    char cc[100];
#ifndef MR_NOFULLWIDTH   
    mip=mirsys(36,0);
#else
    mip=mirsys(36,MAXBASE);
#endif
    a=mirvar(0);
    b=mirvar(0);
    p=mirvar(0);
    q=mirvar(0);
    pk=mirvar(0);  
    m=mirvar(0);   
    x=mirvar(0);
    y=mirvar(0);
    k=mirvar(0);
    k2=mirvar(0);
    inv=mirvar(0);
    inv2=mirvar(0);
    t=mirvar(0);
    nn=mirvar(0);
    yd=mirvar(0);
    z=mirvar(0);
    r=mirvar(0); 
 
    time(&seed);
    irand((unsigned long)seed);   /* change parameter for different values */
    convert(0,r);

    convert(0,a);
    mip->IOBASE=16;
    cinstr(b,ecb);
    cinstr(p,ecp);      
    ecurve_init(a,b,p,MR_BEST);  /* Use PROJECTIVE if possible, else AFFINE coordinates */

    g=epoint_init();
    cinstr(x,ecx);
    cinstr(y,ecy);
    cinstr(nn,ecn);
    mip->IOBASE=10;
    epoint_set(x,y,0,g);
    ek=epoint_init();
    ea=epoint_init();
    eb=epoint_init();
    epoint_copy(g,ea);
    epoint_copy(g,eb);

/* Padding random bytes to data, get ptr */
    ptr = (char*)malloc(ptx_len);
    strcpy(ptr, dest);
	strcat(ptr, rand_string_alloc(rand_len));
    n = strlen(ptr)-rand_len;
    

/*  Encode ptr to m */
    mip->IOBASE=128;
    cinstr(m,ptr); 

/*  Map m to an elliptic curve point ek */
    mip->IOBASE=10;      
    epoint_set(m,m,0,ek);

/*  Key generation algorithm. Generate an epoch key k */
    do 
    {
    bigbits(160,k);
    } while (egcd(k,nn,z)!=1); 
    xgcd(k,nn,inv,yd,z);

/*  Encryption algorithm. Compute a ciphertext */       
    mip->IOBASE=10;      
    epoint_set(m,m,0,ek);
    ecurve_mult(k,ek,ek);
    ik=epoint_get(ek,pk,pk);

    if (fcomp(r,pk)!=0) 
    {
        printf("\nCiphertext= \n");
        cotnum(pk,stdout);
    }
    
/*  Decryption algorithm. Compute the plaintext */
    epoint_set(pk,pk,ik,ek); /* decompress es */  
    ecurve_mult(inv,ek,ek);
    epoint_get(ek,m,m);
    if (fcomp(r,pk)!=0) 
    {
        printf("Plaintext= \n");
        mip->IOBASE=128;
        cotstr(m,c);
        printf("%.*s\n",n,c);
    }

/*  Key generation algorithm. Generate a new epoch key k2 */
    do 
    {
    bigbits(160,k2);
    } while (egcd(k2,nn,z)!=1); 
    xgcd(k2,nn,inv2,yd,z);

/*  Token Generation algorithm. Compute the update token t */
    multiply(k2,inv,t);
    
/*  Update algorithm. Compute the updated ciphertext */
    mip->IOBASE=10;  
    epoint_set(pk,pk,ik,ek); /* decompress es */  
    ecurve_mult(t,ek,ek);
    ik=epoint_get(ek,pk,pk);

    if (fcomp(r,pk)!=0) 
    {
        printf("\nUpdated ciphertext= \n");
        cotnum(pk,stdout);
    }

/*  Compute the plaintext wrt the update ciphertext */
    epoint_set(pk,pk,ik,ek); /* decompress es */  
    ecurve_mult(inv2,ek,ek);
    epoint_get(ek,m,m);
    if (fcomp(r,pk)!=0) 
    {
        printf("Plaintext wrt the update ciphertext= \n");
        mip->IOBASE=128;
        cotstr(m,c);
        printf("%.*s\n",n,c);
    }

    return fcomp(r,pk);
}


static char *rand_string(char *str, size_t size)
{
    const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJK...";
    srand(time(0)); 
    if (size) {
        --size;
        for (size_t n = 0; n < size; n++) {
            int key = rand() % (int) (sizeof charset - 1);
            str[n] = charset[key];
        }
        str[size] = '\0';
    }
    return str;
}

char* rand_string_alloc(size_t size)
{
     char *s = malloc(size + 1);
     free(s);
     srand(time(0)); 
     if (s) {
         rand_string(s, size);
     }
     return s;
}

